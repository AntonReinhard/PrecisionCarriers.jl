var documenterSearchIndex = {"docs":
[{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Types","page":"Public","title":"Types","text":"","category":"section"},{"location":"lib/public/#PrecisionCarriers.PrecisionCarrier","page":"Public","title":"PrecisionCarriers.PrecisionCarrier","text":"PrecisionCarrier{AbstractFloat}\n\nA carrier type for floating points. Most math functions are overloaded for this type. Initialize it with some value (or see precify to convert an entire array or tuple type of numbers), do some arithmetic with your value(s), and finally, print it to check the number of accumulated epsilons of error.\n\njulia> using PrecisionCarriers\n\njulia> function unstable(x, N)\n           y = abs(x)\n           for i in 1:N y = sqrt(y) end\n           w = y\n           for i in 1:N w = w^2 end\n           return w\n       end\nunstable (generic function with 1 method)\n\njulia> unstable(precify(2), 5)\n1.9999999999999964 <ε=8>\n\njulia> unstable(precify(2), 10)\n2.0000000000000235 <ε=53>\n\njulia> unstable(precify(2), 20)\n2.0000000001573586 <ε=354340>\n\njulia> unstable(precify(2), 128)\n1.0 <ε=4503599627370496>\n\n\nnote: Note\nA precision carrier of BigFloat is allowed, but is mostly useful for functions that only use it intermediately. Using a carrier of BigFloat as input for a function will simply result in always 0 ε error reported. Also note that in this case, epsilons is not implemented, because BigFloat does not have a type epsilon.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Macros","page":"Public","title":"Macros","text":"","category":"section"},{"location":"lib/public/#PrecisionCarriers.@bench_epsilons","page":"Public","title":"PrecisionCarriers.@bench_epsilons","text":"@bench_epsilons(call_expr, args...)\n\nBenchmark the epsilons of a given function call.\n\nThe first argument should be a function call, with variables from local context interpolated, and arguments that should be sampled defined in a ranges = begin ... end block. In the ranges block, every variable must be assigned a Tuple of a lower and an upper bound for values that should be sampled.\n\nusing PrecisionCarriers\n\nfoo(x, y) = sqrt(x^2 - y^2)\n\n@bench_epsilons foo(1.0, y) ranges = begin\n    y = (0.5, 1.0)\nend samples = 1000 epsilon_limit = 10\n\nReturned is an object containing information about the benchmark results that can be displayed to a terminal similar to BenchmarkTools' @benchmark.\n\nSupported keyword arguments:\n\nsearch_method: How the sampling should be done. Supported are:\n:pseudo_random: Create pseudo-random sample points in the search space using Sobol.jl.\n:evenly_spaced: Creates an evenly spaced grid across all ranges\n:random: Randomly samples points in the given ranges.\nThe default is :pseudo_random.\nsamples: The number of samples taken. Default: 10000\nepsilon_limit: Results with epsilons larger than this will be stored together with the arguments that produced the imprecise result. Default: 1000\nkeep_n_values: Maximum number of imprecise results that will be stored.\n\n\n\n\n\n","category":"macro"},{"location":"lib/public/#Functions","page":"Public","title":"Functions","text":"","category":"section"},{"location":"lib/public/#PrecisionCarriers.precify","page":"Public","title":"PrecisionCarriers.precify","text":"precify([::Type{PrecisionCarrier{T}}], t::Any) where {T<:AbstractFloat}\nprecify([::Type{T}], t::Any) where {T<:AbstractFloat}\n\nConvert a number or container to a container of PrecisionCarriers. If no specific float type for the PrecisionCarrier is specified, the type of ts floats will be used.\n\njulia> using PrecisionCarriers\n\njulia> precify((0, 1.0, 2.0f0))\n(0.0 <ε=0>, 1.0 <ε=0>, 2.0 <ε=0>)\n\njulia> typeof(ans)\nTuple{PrecisionCarrier{Float64}, PrecisionCarrier{Float64}, PrecisionCarrier{Float32}}\n\njulia> precify(PrecisionCarrier{Float32}, [0, 1.0, 2.0f0])\n3-element Vector{PrecisionCarrier{Float32}}:\n 0.0 <ε=0>\n 1.0 <ε=0>\n 2.0 <ε=0>\n\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PrecisionCarriers.epsilons","page":"Public","title":"PrecisionCarriers.epsilons","text":"epsilons(p::PrecisionCarrier{T})\n\nReturn the number of epsilons of relative difference between p.big and p.x as an EpsT (Int64) value.\n\nnote: Note\nReturns EpsMax (typemax(Int64)) if the difference is infinite, for example when the float reports Inf and the BigT has a non-infinite value.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PrecisionCarriers.significant_digits","page":"Public","title":"PrecisionCarriers.significant_digits","text":"significant_digits(p::PrecisionCarrier{T})\n\nReturn the number of significant decimal digits currently carried by this PrecisionCarrier.\n\njulia> using PrecisionCarriers\n\njulia> function unstable(x, N)\n           y = abs(x)\n           for i in 1:N y = sqrt(y) end\n           w = y\n           for i in 1:N w = w^2 end\n           return w\n       end\nunstable (generic function with 1 method)\n\njulia> unstable(precify(0.5), 30)\n0.4999999971854335 <ε=25351362>\n\njulia> significant_digits(ans)\n8.249558483913594\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PrecisionCarriers.reset_eps!","page":"Public","title":"PrecisionCarriers.reset_eps!","text":"reset_eps!(p::PrecisionCarrier{AbstractFloat})\n\nReset the precision carrier to zero epsilons. Can be called on containers (AbstractArrays or Tuples) to reset all underlying PrecisionCarriers.\n\njulia> using PrecisionCarriers\n\njulia> function unstable(x, N)\n           y = abs(x)\n           for i in 1:N y = sqrt(y) end\n           w = y\n           for i in 1:N w = w^2 end\n           return w\n       end\nunstable (generic function with 1 method)\n\njulia> p = unstable(precify(1.5), 30)\n1.4999996689838975 <ε=993842883>\n\njulia> reset_eps!(p)\n1.4999996689838975 <ε=0>\n\nCustom types can be overloaded by implementing a function dispatching the call downwards to all relevant members. Note that this is a muting operation and therefore requires mutability of the members.\n\nfunction reset_eps!(x::Custom)\n    reset_eps!(x.v1)\n    reset_eps!(x.v2)\n    # ...\n    return x\nend\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.eltype","page":"Public","title":"Base.eltype","text":"Base.eltype(::PrecisionCarrier)\n\nReturn the internally carried floating point type.\n\n\n\n\n\n","category":"function"},{"location":"literal/bench_epsilons/#Benchmarking-Imprecisions-of-a-Function","page":"Benchmarking","title":"Benchmarking Imprecisions of a Function","text":"","category":"section"},{"location":"literal/bench_epsilons/","page":"Benchmarking","title":"Benchmarking","text":"For functions or expressions taking in some amount of floating point numbers and returning a single floating point number, PrecisionCarriers.jl provides a simple macro to quickly check for precision problems:","category":"page"},{"location":"literal/bench_epsilons/","page":"Benchmarking","title":"Benchmarking","text":"using PrecisionCarriers\n\nfoo(x, y) = sqrt(abs(x^2 - y^2))\n\n@bench_epsilons foo(1.0, y) ranges = begin\n    y = (0.5, 1.0)\nend search_method = :evenly_spaced","category":"page"},{"location":"literal/bench_epsilons/","page":"Benchmarking","title":"Benchmarking","text":"Function calls can be nested inside the expression as well, or multiple variables sampled simultaneously:","category":"page"},{"location":"literal/bench_epsilons/","page":"Benchmarking","title":"Benchmarking","text":"@bench_epsilons foo(exp2(x), y) ranges = begin\n    x = (0.5, 2.0)\n    y = (0.0, 2.0)\nend","category":"page"},{"location":"literal/bench_epsilons/","page":"Benchmarking","title":"Benchmarking","text":"To interpolate values from your local scope, use the $ syntax:","category":"page"},{"location":"literal/bench_epsilons/","page":"Benchmarking","title":"Benchmarking","text":"z = 5.0\n\n@bench_epsilons foo(exp2(x), y * $z) ranges = begin\n    x = (1.0, 2.0)\n    y = (0.0, 0.3)\nend search_method = :random","category":"page"},{"location":"literal/bench_epsilons/","page":"Benchmarking","title":"Benchmarking","text":"For information on the supported keyword arguments, see also @bench_epsilons.","category":"page"},{"location":"literal/bench_epsilons/","page":"Benchmarking","title":"Benchmarking","text":"","category":"page"},{"location":"literal/bench_epsilons/","page":"Benchmarking","title":"Benchmarking","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literal/manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"using PrecisionCarriers","category":"page"},{"location":"literal/manual/#Precify","page":"Manual","title":"Precify","text":"","category":"section"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"Create a PrecisionCarrier object from any floating point by using precify:","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"p = precify(1.0)","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"By default, precify uses the type of the given floating point:","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"typeof(precify(1.0f0))","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"typeof(precify(Float16(1.0)))","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"One can also specify the type:","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"typeof(precify(Float32, 1.0))","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"All of these versions also work on array and tuple types:","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"precify((1.0, Float32(2.0), Float16(3.0)))","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"The interface can also easily be extended for custom types by dispatching to all relevant members:","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"struct A\n    x::AbstractFloat\nend\n\nPrecisionCarriers.precify(T::Type{<:PrecisionCarrier}, a::A) = A(precify(a.x))\n\nprecify(A(1.0))","category":"page"},{"location":"literal/manual/#Arithmetic-and-Precision-Estimation","page":"Manual","title":"Arithmetic and Precision Estimation","text":"","category":"section"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"The resulting precified object can be used like a normal floating point number:","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"p = atan((p + 10)^2 * pi)","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"When displaying the result, the number of epsilons (ε) is calculated. It represents the number of machine precision of the underlying floating point type, that it differs relative to the arbitrary precision calculation.","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"p = tan(p)","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"The result is also color graded to draw attention to values that have precision problems.","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"The number of significant digits remaining in the type can be calculated by using significant_digits:","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"significant_digits(p)","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"Finally, the precision carried can be reset using reset_eps!:","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"reset_eps!(p)","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"literal/manual/","page":"Manual","title":"Manual","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literal/example/#Usage-Example","page":"Example","title":"Usage Example","text":"","category":"section"},{"location":"literal/example/","page":"Example","title":"Example","text":"Suppose we have the problem of computing the square root of the positive difference of two squares, x and y. The formula is simple: sqrtleftx^2 - y^2right. Let's write it in julia:","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"f(x, y) = sqrt(abs(x^2 - y^2))\n\nf(5, 4)","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"So far so good. Now what happens when x and y have almost equal values?","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"f(3.0 + 1.0e-7, 3.0)","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"Compare that with a result in arbitrary precision:","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"f(big(3.0 + 1.0e-7), big(3.0))","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"Clearly, not all of the supposed ca. 15 digits that the Float64 result carries are correct. Let's see what PrecisionCarriers says:","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"using PrecisionCarriers\np = f(precify(3.0 + 1.0e-7), precify(3.0))","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"significant_digits(p)","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"It looks like we lost about 5 significant digits! This happens because of the intermediate results of x^2 and y^2 do not carry enough precision to accurately calculate their difference. This is often called \"catastrophic cancellation\", because the two values are almost equal, so many of the most-significant bits are \"cancelled\".","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"In this instance, we can resolve the problem for most cases by replacing x^2 - y^2 with its binomial representation (x + y) * (x - y). This reduces the instability of the intermediate values:","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"f_improved(x, y) = sqrt(abs((x + y) * (x - y)))\np = f_improved(precify(3.0 + 1.0e-7), precify(3.0))","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"significant_digits(p)","category":"page"},{"location":"literal/example/#Benchmarking","page":"Example","title":"Benchmarking","text":"","category":"section"},{"location":"literal/example/","page":"Example","title":"Example","text":"The benchmarking macro @bench_epsilons is very helpful to see the precision loss one can expect from a function at a glance:","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"@bench_epsilons f(x, y) ranges = begin\n    x = (0.0, 5.0)\n    y = (0.0, 5.0)\nend","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"Compare this with the improved version:","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"@bench_epsilons f_improved(x, y) ranges = begin\n    x = (0.0, 5.0)\n    y = (0.0, 5.0)\nend","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"For more information on the @bench_epsilons macro, please refer to its docstring or the tutorial.","category":"page"},{"location":"literal/example/#Plotting","page":"Example","title":"Plotting","text":"","category":"section"},{"location":"literal/example/","page":"Example","title":"Example","text":"We can also easily visualize the precision loss of either version by plotting the significant digits on an x-y-plane:","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"using CairoMakie\n\nx = 1.0:1.0e-6:(1.0 + 1.0e-4)\ny = 1.0:1.0e-6:(1.0 + 1.0e-4)\n\ncontourf(x, y, (x, y) -> significant_digits(f(precify(x), precify(y))))","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"With a little more effort we can compare the two versions on some values:","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"fig = Figure()\n\nz1 = [significant_digits(f(precify(xi), precify(yi))) for yi in y, xi in x]\nz2 = [significant_digits(f_improved(precify(xi), precify(yi))) for yi in y, xi in x]\n\nzmin = floor(Int, min(minimum(z1), minimum(z2)))\nzmax = ceil(Int, max(maximum(z1), maximum(z2)))\n\nax1 = Axis(fig[1, 1]; aspect = AxisAspect(1), title = \"Original f\", xticksvisible = false, yticksvisible = false, xticklabelsvisible = false, yticklabelsvisible = false)\nax2 = Axis(fig[1, 2]; aspect = AxisAspect(1), title = \"Improved f\", xticksvisible = false, yticksvisible = false, xticklabelsvisible = false, yticklabelsvisible = false)\n\ncontour1 = contourf!(ax1, x, y, z1; levels = range(zmin, zmax))\ncontour2 = contourf!(ax2, x, y, z2; levels = range(zmin, zmax))\n\nColorbar(fig[1, 3], contour1; label = \"Significant Digits\")\n\nfig","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"","category":"page"},{"location":"literal/example/","page":"Example","title":"Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contribution/#Contribution","page":"Contribution","title":"Contribution","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Feel free to open issues or pull requests to the official repository. Ideas, tips, bug reports, or contributions are all welcome.","category":"page"},{"location":"#PrecisionCarriers.jl","page":"Index","title":"PrecisionCarriers.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"(Image: tests) (Image: codecov) (Image: docs) (Image: code style: runic)","category":"page"},{"location":"","page":"Index","title":"Index","text":"This is a package to find imprecisions in chains of arithmetic functions.","category":"page"},{"location":"#How-it-Works","page":"Index","title":"How it Works","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This package provides a new type, PrecisionCarrier{T}, which holds both a standard floating point type, and an arbitrary precision BigFloat. Basic arithmetic, trigonometric, and comparison functions are overloaded for this type and always work on both the basic and the arbitrary precision type. When some computations have been done, the values may (or may not) diverge, and the extent of the accumulated precision loss can be evaluated.","category":"page"},{"location":"","page":"Index","title":"Index","text":"This is not a package to directly increase the precision of your calculations. It is only intended to find the issues. To improve precision, you can use higher precision types, use arbitrary precision packages, or rearrange terms to be more numerically stable.","category":"page"},{"location":"#Usage","page":"Index","title":"Usage","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"A floating point number can simply be wrapped in the custom type by calling precify on it. This also works for tuples and arrays, and custom types if an implementation is provided for it. The resulting PrecisionCarrier object can then be used like any AbstractFloat type in most cases. Finally, with significant_digits, the number of remaining significant digits in the variable can be queried.","category":"page"},{"location":"","page":"Index","title":"Index","text":"using PrecisionCarriers\n\n# example function from Prof. Kahan: https://people.eecs.berkeley.edu/~wkahan/WrongR.pdf\nfunction unstable(x, N)\n    y = abs(x)\n    for i in 1:N y = sqrt(y) end\n    w = y\n    for i in 1:N w = w^2 end\n    return w\nend\n\np = precify(1.5)\n\nsignificant_digits(p) # -> 15.65...\n\np = unstable(p, 20)\n\nsignificant_digits(p) # -> 10.39...\n\n# reset the precision carrier\nreset_eps!(p)","category":"page"},{"location":"#Caveats","page":"Index","title":"Caveats","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This method, while helpful in many cases, is not universal and should be used with care:","category":"page"},{"location":"","page":"Index","title":"Index","text":"Some iterative methods (for a simple example, Newton's method) are not very reliant on high precision in every step, since they converge regardless of the precision of intermediate results. This can lead to something that looks like horrible precision loss, but is not actually relevant.\nThe given number of epsilons is not the same as an error of measurement. It should not be used for error bars or similar. It's rather a rough indicator of numerical noise, but for example it can statistically happen that imprecisions cancel each other for certain cases, but this does not indicate better stability.\nEven arbitrary precision has its limits. For the unstable function given above, at about N=256, even the BigFloat will become unstable and the program will incorrectly report perfect precision (because both the normal float and the big float are equally wrong). However, this should only happen in extreme cases where you are likely aware of this. A similar problem can occur for example when a subtraction should result in exactly 0, where in some cases, the basic float type correctly reports 0.0, but the BigFloat calculates some tiny number (like 1e-80). This leads to the PrecisionCarrier reporting ε=Inf, because the relative error between 0 and not 0 is always infinite.\nBigFloat is not usable on GPUs.\nThe use of arbitrary precision adds considerable performance overhead.","category":"page"},{"location":"#License","page":"Index","title":"License","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"MIT © Anton Reinhard","category":"page"},{"location":"#Acknowledgements-and-Funding","page":"Index","title":"Acknowledgements and Funding","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This work was partly funded by the Center for Advanced Systems Understanding (CASUS) that is financed by Germany’s Federal Ministry of Research, Technology and Space (BMFTR) and by the Saxon Ministry for Science, Culture and Tourism (SMWK) with tax funds on the basis of the budget approved by the Saxon State Parliament.","category":"page"},{"location":"lib/internal/#Internal-functions-and-functionality","page":"Internal","title":"Internal functions and functionality","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Pages = [\"internal.md\"]","category":"page"},{"location":"lib/internal/#Constants","page":"Internal","title":"Constants","text":"","category":"section"},{"location":"lib/internal/#PrecisionCarriers.EpsT","page":"Internal","title":"PrecisionCarriers.EpsT","text":"EpsT\n\nThe integer type of epsilons, for example the return type of the epsilons function. Int64 by default.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PrecisionCarriers.EpsMax","page":"Internal","title":"PrecisionCarriers.EpsMax","text":"EpsMax\n\nThe maximum representable number of epsilons. typemax(EpsT) by default. If an epsilon would be larger than this value, it is shown as \"infinite\" epsilons.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internal/#PrecisionCarriers.BigT","page":"Internal","title":"PrecisionCarriers.BigT","text":"BigT\n\nThe backend high precision float type used by PrecisionCarriers.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#Types","page":"Internal","title":"Types","text":"","category":"section"},{"location":"lib/internal/#PrecisionCarriers.TopKSortedList","page":"Internal","title":"PrecisionCarriers.TopKSortedList","text":"TopKSortedList\n\nHelper type to store a certain number of key/value pairs, sorted in descending order by key.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PrecisionCarriers.EpsilonBenchmarkResult","page":"Internal","title":"PrecisionCarriers.EpsilonBenchmarkResult","text":"EpsilonBenchmarkResult\n\nResult object returned by the @bench_epsilons macro. When displayed, it prints a summary of the results, containing the minimum, median, mean, and maximum observed epsilons, and a terminal-styled histogram.\n\nFields:\n\nepsilons: A vector of all non-infinite collected epsilon samples. Infinite epsilons are excluded so that statistical measures do not get skewed.\ntotal_samples: The total number of collected samples.\nworst_arguments: Descending list of the top worst epsilons together with the respective arguments. Helpful for closer inspection of precision problems.\nepsilon_limit: The minimum number of epsilons a result must have to be considered for the worst arguments list.\ncall_string: The call string of the function being benchmarked, with format specifiers to string-interpolate the values.\nno_inf_epsilons: Number of collected samples that gave infinite epsilons.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#Functions","page":"Internal","title":"Functions","text":"","category":"section"},{"location":"lib/internal/#PrecisionCarriers._grid_samples","page":"Internal","title":"PrecisionCarriers._grid_samples","text":"_grid_samples(ranges::Tuple{Vararg{Tuple{<:Real, <:Real}}}, n::Integer)\n\nReturn an iterator generating approximately n evenly spaced samples over the Cartesian grid defined by ranges. Each element of ranges must be a (lo, hi) tuple.\n\nnote: Note\nThe actual number of samples generated is    lfloor n^frac1m rfloor ^ mwhere m is the dimensionality, i.e., number of ranges given.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PrecisionCarriers._random_samples","page":"Internal","title":"PrecisionCarriers._random_samples","text":"_random_samples(ranges::Tuple{Vararg{Tuple{<:Real, <:Real}}}, n::Integer)\n\nReturn an iterator generating n uniform randomly generated samples over the Cartesian grid defined by ranges. Each element of ranges must be a (lo, hi) tuple.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PrecisionCarriers._pseudo_random_samples","page":"Internal","title":"PrecisionCarriers._pseudo_random_samples","text":"_pseudo_random_samples(ranges::Tuple{Vararg{Tuple{<:Real, <:Real}}}, n::Integer)\n\nReturn an iterator generating n pseudo-randomly generated samples over the Cartesian grid defined by ranges. Each element of ranges must be a (lo, hi) tuple. This uses the package Sobol.jl to produce pseudorandom numbers within the given hypercube. The resulting numbers are more predictable and evenly spaced than real randomness, which can be better to sample a high dimensional space. Also, the generated samples are reproducible.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PrecisionCarriers.make_bins","page":"Internal","title":"PrecisionCarriers.make_bins","text":"make_bins(\n    vec::Vector{EpsT},\n    min_val::EpsT,\n    max_val::EpsT,\n    mean_val::AbstractFloat,\n    median_val::AbstractFloat,\n    histogram_width::Int\n)\n\nHelper function for printing EpsilonBenchmarkResult. Returns a tuple (hist, mean_bin, median_bin), where hist is a vector of length histogram_width. The elements represent the number of results (from the given vec) in the bin. mean_bin and median_bin contain the bins that the given mean_val and median_val fall in. min_val and max_val are used to scale the histogram appropriately. The histogram bins are sized logarithmically, which also means that 0 values are ignored. This function errors when the difference between min_val and max_val is 1 or less, or when min_val is 0 or less.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PrecisionCarriers.ascii_hist","page":"Internal","title":"PrecisionCarriers.ascii_hist","text":"ascii_hist(io::IO, bins::Vector{Int}, mean_bin::Int, median_bin::Int)\n\nPrints the given histogram (bins) to the given io. The mean and median bins are colored in their respective colors.\n\nnote: Note\nThe implementation is copied and slightly adapted from BenchmarkTools.jl.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PrecisionCarriers.print_hist_info","page":"Internal","title":"PrecisionCarriers.print_hist_info","text":"print_hist_info(io::IO, histogram_width::Int, minval::EpsT, maxval::EpsT)\n\nTo be called after ascii_hist. Prints a line below the histogram marking the minimum and maximum value.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PrecisionCarriers._special_epsilon","page":"Internal","title":"PrecisionCarriers._special_epsilon","text":"_special_epsilon(p::P{T})\n\nReturns:\n\n_NORM_EPS if neither p.x nor p.big need special treatment\n_INF_EPS if p.x or p.big have special values and the epsilon should be considered infinite\n_ZERO_EPS if p.x or p.big have special values and the epsilon should be considered zero\n\n\n\n\n\n","category":"function"},{"location":"extensions/#Package-Extensions","page":"Extensions","title":"Package Extensions","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Some extensions for interoperability with other packages are provided.","category":"page"},{"location":"extensions/#Random","page":"Extensions","title":"Random","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"An extension for the Base.Random package is provided, overloading rand functions. When Random is loaded, one can therefore generate random numbers just like for Floats:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using PrecisionCarriers\nusing Random\n\nrand(PrecisionCarrier{Float16})","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"rand(PrecisionCarrier{Float32})","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"rand(PrecisionCarrier)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Furthermore, when using a specific (seeded) generator, the produced values are reproducible with the non-wrapped Float generator:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"@assert rand(MersenneTwister(0)) == rand(MersenneTwister(0), PrecisionCarrier)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"The same is true for arrays of random numbers:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"@assert rand(MersenneTwister(0), Float32, (5, 5)) == rand(MersenneTwister(0), PrecisionCarrier{Float32}, (5, 5))","category":"page"},{"location":"extensions/#[DoubleFloats.jl](https://github.com/JuliaMath/DoubleFloats.jl/)","page":"Extensions","title":"DoubleFloats.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"This is an extension for a package providing DoubleFloat types, which internally store two floats, a hi and a lo one. These can be used for better precision without resorting to larger types (which may not be supported on GPUs, for example). When this package is loaded, they can be precify'd and used just like basic Float types.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using PrecisionCarriers\nusing DoubleFloats\n\nprecify(df64\"0.1\")","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"d = DoubleFloat(precify(1.0e3))","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"tan(atan(d))","category":"page"}]
}
